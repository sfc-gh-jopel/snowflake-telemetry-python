# Generated by the protoc compiler with a custom plugin. DO NOT EDIT!
# sources: opentelemetry/proto/trace/v1/trace.proto

from typing import (
    List,
    Optional,
)

from snowflake.telemetry._internal.serialize import (
    Enum,
    ProtoSerializer,
)


class SpanFlags(Enum):
    SPAN_FLAGS_DO_NOT_USE = 0
    SPAN_FLAGS_TRACE_FLAGS_MASK = 255
    SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK = 256
    SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK = 512


def TracesData(
    resource_spans: Optional[List[bytes]] = None,
) -> bytes:
    proto_serializer = ProtoSerializer()
    if resource_spans:
        proto_serializer.serialize_repeated_message(b"\n", resource_spans)
    return proto_serializer.out


def ResourceSpans(
    resource: Optional[bytes] = None,
    scope_spans: Optional[List[bytes]] = None,
    schema_url: Optional[str] = None,
) -> bytes:
    proto_serializer = ProtoSerializer()
    if resource is not None:
        proto_serializer.serialize_message(b"\n", resource)
    if scope_spans:
        proto_serializer.serialize_repeated_message(b"\x12", scope_spans)
    if schema_url:
        proto_serializer.serialize_string(b"\x1a", schema_url)
    return proto_serializer.out


def ScopeSpans(
    scope: Optional[bytes] = None,
    spans: Optional[List[bytes]] = None,
    schema_url: Optional[str] = None,
) -> bytes:
    proto_serializer = ProtoSerializer()
    if scope is not None:
        proto_serializer.serialize_message(b"\n", scope)
    if spans:
        proto_serializer.serialize_repeated_message(b"\x12", spans)
    if schema_url:
        proto_serializer.serialize_string(b"\x1a", schema_url)
    return proto_serializer.out


def Span(
    trace_id: Optional[bytes] = None,
    span_id: Optional[bytes] = None,
    trace_state: Optional[str] = None,
    parent_span_id: Optional[bytes] = None,
    name: Optional[str] = None,
    kind: Optional[int] = None,
    start_time_unix_nano: Optional[int] = None,
    end_time_unix_nano: Optional[int] = None,
    attributes: Optional[List[bytes]] = None,
    dropped_attributes_count: Optional[int] = None,
    events: Optional[List[bytes]] = None,
    dropped_events_count: Optional[int] = None,
    links: Optional[List[bytes]] = None,
    dropped_links_count: Optional[int] = None,
    status: Optional[bytes] = None,
    flags: Optional[int] = None,
) -> bytes:
    proto_serializer = ProtoSerializer()
    if trace_id:
        proto_serializer.serialize_bytes(b"\n", trace_id)
    if span_id:
        proto_serializer.serialize_bytes(b"\x12", span_id)
    if trace_state:
        proto_serializer.serialize_string(b"\x1a", trace_state)
    if parent_span_id:
        proto_serializer.serialize_bytes(b'"', parent_span_id)
    if name:
        proto_serializer.serialize_string(b"*", name)
    if kind:
        proto_serializer.serialize_enum(b"0", kind)
    if start_time_unix_nano:
        proto_serializer.serialize_fixed64(b"9", start_time_unix_nano)
    if end_time_unix_nano:
        proto_serializer.serialize_fixed64(b"A", end_time_unix_nano)
    if attributes:
        proto_serializer.serialize_repeated_message(b"J", attributes)
    if dropped_attributes_count:
        proto_serializer.serialize_uint32(b"P", dropped_attributes_count)
    if events:
        proto_serializer.serialize_repeated_message(b"Z", events)
    if dropped_events_count:
        proto_serializer.serialize_uint32(b"`", dropped_events_count)
    if links:
        proto_serializer.serialize_repeated_message(b"j", links)
    if dropped_links_count:
        proto_serializer.serialize_uint32(b"p", dropped_links_count)
    if status is not None:
        proto_serializer.serialize_message(b"z", status)
    if flags:
        proto_serializer.serialize_fixed32(b"\x85\x01", flags)
    return proto_serializer.out


class Span_SpanKind(Enum):
    SPAN_KIND_UNSPECIFIED = 0
    SPAN_KIND_INTERNAL = 1
    SPAN_KIND_SERVER = 2
    SPAN_KIND_CLIENT = 3
    SPAN_KIND_PRODUCER = 4
    SPAN_KIND_CONSUMER = 5


def Span_Event(
    time_unix_nano: Optional[int] = None,
    name: Optional[str] = None,
    attributes: Optional[List[bytes]] = None,
    dropped_attributes_count: Optional[int] = None,
) -> bytes:
    proto_serializer = ProtoSerializer()
    if time_unix_nano:
        proto_serializer.serialize_fixed64(b"\t", time_unix_nano)
    if name:
        proto_serializer.serialize_string(b"\x12", name)
    if attributes:
        proto_serializer.serialize_repeated_message(b"\x1a", attributes)
    if dropped_attributes_count:
        proto_serializer.serialize_uint32(b" ", dropped_attributes_count)
    return proto_serializer.out


def Span_Link(
    trace_id: Optional[bytes] = None,
    span_id: Optional[bytes] = None,
    trace_state: Optional[str] = None,
    attributes: Optional[List[bytes]] = None,
    dropped_attributes_count: Optional[int] = None,
    flags: Optional[int] = None,
) -> bytes:
    proto_serializer = ProtoSerializer()
    if trace_id:
        proto_serializer.serialize_bytes(b"\n", trace_id)
    if span_id:
        proto_serializer.serialize_bytes(b"\x12", span_id)
    if trace_state:
        proto_serializer.serialize_string(b"\x1a", trace_state)
    if attributes:
        proto_serializer.serialize_repeated_message(b'"', attributes)
    if dropped_attributes_count:
        proto_serializer.serialize_uint32(b"(", dropped_attributes_count)
    if flags:
        proto_serializer.serialize_fixed32(b"5", flags)
    return proto_serializer.out


def Status(
    message: Optional[str] = None,
    code: Optional[int] = None,
) -> bytes:
    proto_serializer = ProtoSerializer()
    if message:
        proto_serializer.serialize_string(b"\x12", message)
    if code:
        proto_serializer.serialize_enum(b"\x18", code)
    return proto_serializer.out


class Status_StatusCode(Enum):
    STATUS_CODE_UNSET = 0
    STATUS_CODE_OK = 1
    STATUS_CODE_ERROR = 2
